#!/bin/bash

debug() {
  local -n arr="$1"
  printf '\n%s\n' "DEBUG: ${!arr}"
  for flag in "${!arr[@]}"; do
    printf ' [%s]=%s\n' "${flag}" "${arr[${flag}]}"
  done
}

## Flag parsing

# Registration
register_opt() {
  local -r name="$1"
  local -r opts="$2"
  local -r num_args="${3:-0}"
  local -r required="${4:-false}"
  local -r default="$5"
  local -r store="$6"
  local -r instances="${7:-1}"

  OPTS["${name}"]="${opts}"
  NUM_OPT_ARGS["${name}"]="${num_args}"
  REQUIRED["${name}"]="${required}"
  DEFAULTS["${name}"]="${default}"
  STORE["${name}"]="${store}"
  INSTANCES["${name}"]="${instances}"

  VALUES["${name}"]=''
  COUNTS["${name}"]=0
}

register_opt_value() {
  local -r name="$1"
  local -n attr="$2"
  local -r val="$3"

  attr["${name}"]="${val}"
}

register_pos() {
  local -r name="$1"
  local -r num_args="${2:-0}"
  local -r required="${3:-'true'}"

  NUM_POS_ARGS["${name}"]="${num_args}"
  POS_REQUIRED["${name}"]="${required}"
  POS_ORDER+=("${name}")

  POS_PARSED["${name}"]=''
}


# Err messages
missing_args() {
  local -r _name="$1"
  local -r _req="$2"
  local -r _prov="$3"
  printf '%s\n%s\n' \
    "Error: '${_name}' has required arguments: ${_req}" \
    "Provided: ${_prov}" \
    >&2
}

missing_required() {
  local -r _name="$1"
  printf '%s\n' "Error: missing required option: ${_name}" >&2
}

too_many_instances() {
  local -r _name="$1"
  local -r _count="$2"
  local -r _max="$3"
  printf '%s\n%s\n%s\n' \
    "Error: '${_name}' has too many instances." \
    "Given: ${_count}" \
    "Max: ${_max}" \
    >&2
}

missing_pos_args() {
  local -r _name="$1"
  local -r _num="$2"
  local -r _actual="$3"
  printf '%s\n%s\n%s\n' \
    "Error: '${_name}' is missing positional arguments." \
    "Given: ${_actual}" \
    "Required: ${_num}" \
    >&2
}

too_many_pos_args() {
  printf 'Error: too many positional arguments provided\n' >&2
}

missing_required_pos() {
  local -r _name="$1"
  printf '%s\n' "Error: missing required positional argument '${_name}'" >&2
}

# Processing
consume_flag() {
  local -r name="$1" ; shift 2
  
  local num_args="${NUM_OPT_ARGS[${name}]}"

  local -a args=()

  if (( num_args == 0 )); then
    args+=("${STORE[${name}]}")
  fi
  
  while (( "$num_args" )); do
    local arg="$1" ; shift 1

    if [[ -z "${arg}" ]]; then
      missing_args "${OPTS[${name}]}" "${NUM_OPT_ARGS[$name]}" "${args[*]}"
      return 1
    fi

    for flag in "${OPTS[@]}"; do
      if [[ "${arg}" =~ ${flag} ]]; then
        missing_args "${OPTS[${name}]}" "${NUM_OPT_ARGS[$name]}" "${args[*]}"
        return 1
      fi
    done

    args+=("${arg}")
    (( num_args-- ))
  done

  VALUES["${name}"]="${args[@]}"
  (( COUNTS["${name}"] += 1 ))
}

consume_pos() {
  for pos in "${POS_ORDER[@]}"; do
    local num_pos_args="${NUM_POS_ARGS[${pos}]}"

    local params=()
    while (( num_pos_args != 0 && $# )); do
      params+=("$1")
      shift 1
      (( num_pos_args-- ))
    done

    if (( num_pos_args > 0 )); then
      missing_pos_args "${pos}" "${num_pos_args}" "${params[*]}"
      return 1
    fi

    POS_PARSED["${pos}"]="${params[*]}"

    local required="${POS_REQUIRED[${pos}]}"
    if [[ "${required}" == 'true' && -z "${POS_PARSED[${pos}]}" ]]; then
      missing_required_pos "${pos}"
      return 1
    fi
  done

  if (( $# )); then
    too_many_pos_args
    return 1
  fi
}


# Validation
validate_opts() {
  # Required
  for flag in "${!REQUIRED[@]}"; do
    local required="${REQUIRED[${flag}]}"
    local value="${VALUES[${flag}]}"
    if [[ "${required}" == 'true' && -z "${value}" ]]; then
      missing_required "${OPTS[${flag}]}"
      return 1
    fi
  done

  # Instances
  for flag in "${!INSTANCES[@]}"; do
    local max_instances="${INSTANCES[${flag}]}"
    local count="${COUNTS[${flag}]}"
    if (( count > max_instances )); then
      too_many_instances "${OPTS[${flag}]}" "${count}" "${max_instances}"
      return 1
    fi
  done

  # Defaults
  for flag in "${!VALUES[@]}"; do
    local value="${VALUES[${flag}]}"
    local default="${DEFAULTS[${flag}]}"
    if [[ -z "${value}" ]]; then
      VALUES["${flag}"]="${default}"
    fi
  done
}

# Option arguments
declare -A OPTS
declare -A NUM_OPT_ARGS
declare -A REQUIRED
declare -A DEFAULTS
declare -A STORE
declare -A INSTANCES

declare -A VALUES
declare -A COUNTS

#              name            opts             num_args      required      default    store
register_opt   'FLAG'          '-f|--flag'      0             'false'       'false'    'true'
register_opt   'DEFAULT_FLAG'  '-d|--default'   0             'false'       'DEFAULT'  'NEW'

register_opt 'FLAG_ARG' '-a|--arg'
register_opt_value 'FLAG_ARG' NUM_OPT_ARGS  1
register_opt_value 'FLAG_ARG' REQUIRED  'true'

register_opt 'SINGLE_FLAG' '-s|--single'
register_opt_value 'SINGLE_FLAG' STORE      'SET'
register_opt_value 'SINGLE_FLAG' INSTANCES  1

register_opt 'MULTI_ARG' '-m|--multi'
register_opt_value 'MULTI_ARG' NUM_OPT_ARGS   1
register_opt_value 'MULTI_ARG' INSTANCES  2

# Positional arguments
declare -A NUM_POS_ARGS
declare -A POS_REQUIRED
declare -a POS_ORDER

declare -a POS_RAW
declare -A POS_PARSED

#             name                num_args      required
register_pos  'SINGLE_POS'        1             'true'
register_pos  'MULTI_POS'         2             'true'
register_pos  'INF_POS'           -1            'true'

while (( "$#" )); do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    -f|--flag)
      consume_flag 'FLAG' "$@" || exit 1
      shift 1
      ;;
    -a|--arg)
      consume_flag 'FLAG_ARG' "$@" || exit 1
      shift 2
      ;;
    -d|--default)
      consume_flag 'DEFAULT_FLAG' "$@" || exit 1
      shift 1
      ;;
    -s|--single)
      consume_flag 'SINGLE_FLAG' "$@" || exit 1
      shift 1
      ;;
    -m|--multi)
      consume_flag 'MULTI_ARG' "$@" || exit 1
      shift 2
      ;;
    --) # End argument parsing
      shift
      POS_RAW+=("$@")
      break
      ;;
    -*|--*=) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
    *) # preserve positional arguments
      POS_RAW+=("$1")
      shift
      ;;
  esac
done

consume_pos "${POS_RAW[@]}" || exit 1

validate_opts || exit 1

echo
echo "Options:"
for flag in "${!VALUES[@]}"; do
  printf ' [%s]=%s\n' "${flag}" "${VALUES[${flag}]}"
done

echo
echo "Positional:"
for pos in "${!POS_PARSED[@]}"; do
  printf ' %s: %s\n' "${pos}" "${POS_PARSED[${pos}]}"
done
